daml 1.2

module DAVL where
import DAVLA qualified as A
import DAVLB qualified as B
import DA.List
import DA.Foldable (forA_)
import qualified DA.Next.Map as M
import DA.Action
import DA.Upgrade (convert, Convertible)
import qualified Daml.Trigger as T
import qualified Daml.Script as S

-----------------
-- Upgrade process
template Upgrade
  with
      operator : Party
      authorizers : [Party]
      observers : [Party]
  where
      signatory (operator::authorizers)
      observer observers
      key authorizers : [Party]
      maintainer key

      nonconsuming choice GetAuthority : ()
        with
          authorizingParty : Party
        controller operator
          do
            exerciseByKey @UpgradeToken authorizingParty GiveAuthority with k = authorizers
            pure ()

      nonconsuming choice AddAuthority : ()
        with
          authorizingParty : Party
        controller authorizingParty
          do
            archive self
            create this with authorizers = dedupSort $ authorizingParty :: authorizers
            pure ()

      nonconsuming choice Reset : ()
        with
        controller operator
          do
            archive self
            create $ Upgrade with authorizers = [], operator = operator, observers = observers
            pure ()

      -- we could also do all nonconsuming choices and be completely async and then clean up after
      -- each upgrade
      -- nonconsuming choice  Cleanup : ()
        -- with
        -- controller operator
            -- do
              -- unless (null $ authorizers) do
                -- forA_ (tail $ inits authorizers) $ \k -> do
                  -- (cId, _c) <- fetchByKey @Upgrade k
                  -- archive cId

      -- The model upgrade process
      ----------------------------
      nonconsuming choice EmployeeProposal_CollectAuthority : ()
        with
          inC : ContractId A.EmployeeProposal
        controller operator
          do
            d <- fetch inC
            let sigs = signatory d
            foldlA (\acc sig -> do
              exerciseByKey @Upgrade acc GetAuthority with authorizingParty = sig
              pure (dedupSort $ sig::acc)
              ) authorizers (sigs \\ authorizers)
            pure ()

      nonconsuming choice EmployeeProposal_Go : ContractId B.EmployeeProposal
        with
          inC : ContractId A.EmployeeProposal
        controller operator
          do
            d <- fetch inC
            archive inC
            cid <- create $ convert d
            exercise self Reset
            pure cid

      nonconsuming choice EmployeeProposal_DoUpgrade : ()
        with
          inC : ContractId A.EmployeeProposal
        controller operator
          do
            d <- fetch inC
            exercise self EmployeeProposal_CollectAuthority with inC = inC
            exerciseByKey @Upgrade (dedupSort $ signatory d) EmployeeProposal_Go with inC = inC
            pure ()

      -------------------------
      nonconsuming choice Vacation_CollectAuthority : ()
        with
          inC : ContractId A.Vacation
        controller operator
          do
            d <- fetch inC
            let sigs = signatory d
            foldlA (\acc sig -> do
              exerciseByKey @Upgrade acc GetAuthority with authorizingParty = sig
              pure (dedupSort $ sig::acc)
              ) authorizers (sigs \\ authorizers)
            pure ()

      nonconsuming choice Vacation_Go : ContractId B.Vacation
        with
          inC : ContractId A.Vacation
        controller operator
          do
            d <- fetch inC
            archive inC
            cid <- create $ convert d
            exercise self Reset
            pure cid

      nonconsuming choice Vacation_DoUpgrade : ()
        with
          inC : ContractId A.Vacation
        controller operator
          do
            d <- fetch inC
            exercise self Vacation_CollectAuthority with inC = inC
            exerciseByKey @Upgrade (dedupSort $ signatory d) Vacation_Go with inC = inC
            pure ()

      -------------------------
      nonconsuming choice EmployeeVacationAllocation_CollectAuthority : ()
        with
          inC : ContractId A.EmployeeVacationAllocation
        controller operator
          do
            d <- fetch inC
            let sigs = signatory d
            foldlA (\acc sig -> do
              exerciseByKey @Upgrade acc GetAuthority with authorizingParty = sig
              pure (dedupSort $ sig::acc)
              ) authorizers (sigs \\ authorizers)
            pure ()

      nonconsuming choice EmployeeVacationAllocation_Go : ContractId B.EmployeeVacationAllocation
        with
          inC : ContractId A.EmployeeVacationAllocation
        controller operator
          do
            d <- fetch inC
            archive inC
            cid <- create $ convert d
            exercise self Reset
            pure cid

      nonconsuming choice EmployeeVacationAllocation_DoUpgrade : ()
        with
          inC : ContractId A.EmployeeVacationAllocation
        controller operator
          do
            d <- fetch inC
            exercise self EmployeeVacationAllocation_CollectAuthority with inC = inC
            exerciseByKey @Upgrade (dedupSort $ signatory d) EmployeeVacationAllocation_Go with inC = inC
            pure ()

      -------------------------
      nonconsuming choice VacationRequest_CollectAuthority : ()
        with
          inC : ContractId A.VacationRequest
        controller operator
          do
            d <- fetch inC
            let sigs = signatory d
            foldlA (\acc sig -> do
              exerciseByKey @Upgrade acc GetAuthority with authorizingParty = sig
              pure (dedupSort $ sig::acc)
              ) authorizers (sigs \\ authorizers)
            pure ()

      nonconsuming choice VacationRequest_Go : ContractId B.VacationRequest
        with
          inC : ContractId A.VacationRequest
        controller operator
          do
            d <- fetch inC
            archive inC
            cid <- create $ convert d
            exercise self Reset
            pure cid

      nonconsuming choice VacationRequest_DoUpgrade : ()
        with
          inC : ContractId A.VacationRequest
        controller operator
          do
            d <- fetch inC
            exercise self VacationRequest_CollectAuthority with inC = inC
            exerciseByKey @Upgrade (dedupSort $ signatory d) VacationRequest_Go with inC = inC
            pure ()

      -------------------------
      nonconsuming choice EmployeeRole_CollectAuthority : ()
        with
          inC : ContractId A.EmployeeRole
        controller operator
          do
            d <- fetch inC
            let sigs = signatory d
            foldlA (\acc sig -> do
              exerciseByKey @Upgrade acc GetAuthority with authorizingParty = sig
              pure (dedupSort $ sig::acc)
              ) authorizers (sigs \\ authorizers)
            pure ()

      nonconsuming choice EmployeeRole_Go : ContractId B.EmployeeRole
        with
          inC : ContractId A.EmployeeRole
        controller operator
          do
            d <- fetch inC
            archive inC
            cid <- create $ convert d
            exercise self Reset
            pure cid

      nonconsuming choice EmployeeRole_DoUpgrade : ()
        with
          inC : ContractId A.EmployeeRole
        controller operator
          do
            d <- fetch inC
            exercise self EmployeeRole_CollectAuthority with inC = inC
            exerciseByKey @Upgrade (dedupSort $ signatory d) EmployeeRole_Go with inC = inC
            pure ()

template UpgradeToken
  with
      authorizingParty : Party
      operator : Party
  where
      signatory authorizingParty
      observer operator
      key authorizingParty : Party
      maintainer key

      nonconsuming choice GiveAuthority : ()
        with
          k : [Party]
        controller operator
          do
            exerciseByKey @Upgrade k AddAuthority with authorizingParty
            pure ()

-----------------------
-- Contract conversions

instance Convertible A.Vacation B.Vacation where
    convert A.Vacation{..} = B.Vacation {B.employeeRole = convert employeeRole, ..}
instance Convertible B.Vacation A.Vacation where
    convert B.Vacation{..} = A.Vacation {A.employeeRole = convert employeeRole, ..}
instance Convertible A.EmployeeVacationAllocation B.EmployeeVacationAllocation where
    convert A.EmployeeVacationAllocation{..} = B.EmployeeVacationAllocation {B.employeeRole = convert employeeRole, ..}
instance Convertible B.EmployeeVacationAllocation A.EmployeeVacationAllocation where
    convert B.EmployeeVacationAllocation{..} = A.EmployeeVacationAllocation {A.employeeRole = convert employeeRole, ..}
instance Convertible A.VacationRequest B.VacationRequest where
    convert A.VacationRequest{..} = B.VacationRequest {B.vacation = convert vacation}
instance Convertible B.VacationRequest A.VacationRequest where
    convert B.VacationRequest{..} = A.VacationRequest {A.vacation = convert vacation}
instance Convertible A.EmployeeRole B.EmployeeRole where
    convert A.EmployeeRole{..} = B.EmployeeRole {..}
instance Convertible B.EmployeeRole A.EmployeeRole where
    convert B.EmployeeRole{..} = A.EmployeeRole {..}
instance Convertible A.EmployeeProposal B.EmployeeProposal where
    convert A.EmployeeProposal{..} = B.EmployeeProposal {B.employeeRole = convert employeeRole, ..}
instance Convertible B.EmployeeProposal A.EmployeeProposal where
    convert B.EmployeeProposal{..} = A.EmployeeProposal {A.employeeRole = convert employeeRole, ..}


-------------------------
-- Nano daml trigger bots

-- Upgrade whenever user signaled consent with the creation of a token
-- This doesn't work yet and runs into a daml-lf typechecker error.
upgradeTrigger : T.Trigger ()
upgradeTrigger = T.Trigger
  { initialize = \_acs -> ()
  , updateState = \_acs _message () -> ()
  , rule = upgradeRule
  , registeredTemplates =
      T.RegisteredTemplates
        [ T.registeredTemplate @UpgradeToken
        , T.registeredTemplate @Upgrade
        , T.registeredTemplate @(A.Vacation)
        , T.registeredTemplate @(A.EmployeeVacationAllocation)
        , T.registeredTemplate @(A.VacationRequest)
        , T.registeredTemplate @(A.EmployeeRole)
        , T.registeredTemplate @(A.EmployeeProposal)
        ]
  }

upgradeRule : Party -> T.ACS -> M.Map T.CommandId [T.Command] -> () -> T.TriggerA ()
upgradeRule operator acs commandsInFlight () = do

  -- upgrade EmployeeProposal
  let employeeProposalTokens
        = T.getContracts @UpgradeToken acs
  let employeeProposalCs = T.getContracts @(A.EmployeeProposal) acs
  let employeeProposalUpgrades = T.getContracts @Upgrade acs
  let ready = do
              -- this relies on the fact that there is only one upgrade contract
              (updCid, upd) <- employeeProposalUpgrades
              (cId, c) <- employeeProposalCs
              let sigs = signatory c
              let tokens = [authorizingParty | (_cId, UpgradeToken{authorizingParty, operator}) <- employeeProposalTokens, operator == operator, authorizingParty `elem` sigs]
              guard $ length tokens == length sigs
              pure (updCid, cId)
  forA_ ready $ \(updCid, cId) -> T.dedupExercise updCid EmployeeProposal_DoUpgrade with inC = cId

  -- upgrade Vacation
  let vacationTokens
        = T.getContracts @UpgradeToken acs
  let vacationCs = T.getContracts @(A.Vacation) acs
  let vacationUpgrades = T.getContracts @Upgrade acs
  let ready = do
              -- this relies on the fact that there is only one upgrade contract
              (updCid, upd) <- vacationUpgrades
              (cId, c) <- vacationCs
              let sigs = signatory c
              let tokens = [authorizingParty | (_cId, UpgradeToken{authorizingParty, operator}) <- vacationTokens, operator == operator, authorizingParty `elem` sigs]
              guard $ length tokens == length sigs
              pure (updCid, cId)
  forA_ ready $ \(updCid, cId) -> T.dedupExercise updCid Vacation_DoUpgrade with inC = cId

  -- upgrade EmployeeVacationAllocation
  let employeeVacationAllocationTokens
        = T.getContracts @UpgradeToken acs
  let employeeVacationAllocationCs = T.getContracts @(A.EmployeeVacationAllocation) acs
  let employeeVacationAllocationUpgrades = T.getContracts @Upgrade acs
  let ready = do
              -- this relies on the fact that there is only one upgrade contract
              (updCid, upd) <- employeeVacationAllocationUpgrades
              (cId, c) <- employeeVacationAllocationCs
              let sigs = signatory c
              let tokens = [authorizingParty | (_cId, UpgradeToken{authorizingParty, operator}) <- employeeVacationAllocationTokens, operator == operator, authorizingParty `elem` sigs]
              guard $ length tokens == length sigs
              pure (updCid, cId)
  forA_ ready $ \(updCid, cId) -> T.dedupExercise updCid EmployeeVacationAllocation_DoUpgrade with inC = cId

  -- upgrade VacationRequest
  let vacationRequestTokens
        = T.getContracts @UpgradeToken acs
  let vacationRequestCs = T.getContracts @(A.VacationRequest) acs
  let vacationRequestUpgrades = T.getContracts @Upgrade acs
  let ready = do
              -- this relies on the fact that there is only one upgrade contract
              (updCid, upd) <- vacationRequestUpgrades
              (cId, c) <- vacationRequestCs
              let sigs = signatory c
              let tokens = [authorizingParty | (_cId, UpgradeToken{authorizingParty, operator}) <- vacationRequestTokens, operator == operator, authorizingParty `elem` sigs]
              guard $ length tokens == length sigs
              pure (updCid, cId)
  forA_ ready $ \(updCid, cId) -> T.dedupExercise updCid VacationRequest_DoUpgrade with inC = cId

  -- upgrade EmployeeRole
  let employeeRoleTokens
        = T.getContracts @UpgradeToken acs
  let employeeRoleCs = T.getContracts @(A.EmployeeRole) acs
  let employeeRoleUpgrades = T.getContracts @Upgrade acs
  let ready = do
              -- this relies on the fact that there is only one upgrade contract
              (updCid, upd) <- employeeRoleUpgrades
              (cId, c) <- employeeRoleCs
              let sigs = signatory c
              let tokens = [authorizingParty | (_cId, UpgradeToken{authorizingParty, operator}) <- employeeRoleTokens, operator == operator, authorizingParty `elem` sigs]
              guard $ length tokens == length sigs
              pure (updCid, cId)
  forA_ ready $ \(updCid, cId) -> T.dedupExercise updCid EmployeeRole_DoUpgrade with inC = cId

-- Tests
--------
test : S.Script ()
test = do
  alice <- S.allocateParty "Alice"
  bob <- S.allocateParty "Bob"
  company <- S.allocateParty "DA"
  debug "allocated parties"
  let employeeRole = A.EmployeeRole
                      with A.employee = alice
                           A.boss = bob
                           A.company = company
  propCid <- S.submit company $
    S.createCmd $ A.EmployeeProposal with A.employeeRole = employeeRole; vacationDays = 30
  debug "employee proposal"
  S.submit alice $ S.exerciseCmd propCid $ A.EmployeeProposal_Accept
  debug "proposal accept"
  -- This step fails because toAnyChoice is not implemented in the lf conversion of `external`.
  upCid <- S.submit company $
    S.createCmd @(Upgrade) $ Upgrade {operator = company, authorizers = [], observers = [alice, bob]}
  debug "upgrade creation"
  token <- S.submit alice $
    S.createCmd @(UpgradeToken) $ UpgradeToken{operator = company, authorizingParty = alice}
  debug "token creation"

  cs <- S.query @A.EmployeeRole alice
  debug $ "employee role query" <> (show $ length cs)
  case cs of
    [(cid, _c)] ->
      S.submit company $ do
        S.exerciseCmd upCid $ EmployeeRole_DoUpgrade with inC = cid
    _ -> error "daml query"

test0 : Scenario ()
test0 = do
  alice <- getParty "Alice"
  bob <- getParty "Bob"
  company <- getParty "DA"
  let employeeRole = A.EmployeeRole
                      with A.employee = alice
                           A.boss = bob
                           A.company = company
  propCid <- submit company $
    create $ A.EmployeeProposal with A.employeeRole = employeeRole; vacationDays = 30
  submit alice $ exercise propCid $ A.EmployeeProposal_Accept
  upCid <- submit company $
    create @(Upgrade) $ Upgrade {operator = company, authorizers = [], observers = [alice, bob]}
  token <- submit alice $
    create @(UpgradeToken) $ UpgradeToken{operator = company, authorizingParty = alice}
  pure ()
