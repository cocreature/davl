daml 1.2

module DAVL where
import DAVLA qualified as A
import DAVLB qualified as B
import DA.List hiding (head)
import DA.List.Total (head)
import DA.Foldable (forA_)
import qualified DA.Next.Map as M
import DA.Action
import DA.Upgrade (convert, Convertible)
import Daml.Trigger

-----------------
-- Upgrade process
template (Template i, Template o, Convertible i o, UpgradeTokenInstance i o) => Upgrade i o
  with
      op : Party
      authorizers : [Party]
      obs : [Party]
  where
      signatory (op::authorizers)
      observer obs
      key authorizers : [Party]
      maintainer key

      nonconsuming choice GetAuthority : ()
        with
          p : Party
        controller op
          do
            exerciseByKey @(UpgradeToken i o) p GiveAuthority with k = authorizers
            pure ()

      nonconsuming choice AddAuthority : ()
        with
          p : Party
        controller p
          do
            create this with authorizers = dedupSort $ p :: authorizers
            pure ()

      nonconsuming choice CollectAuthority : ()
        with
          inC : ContractId i
        controller op
          do
            d <- fetch inC
            let sigs = signatory d
            foldlA (\acc sig -> do
              exerciseByKey @(Upgrade i o) acc GetAuthority with p = sig
              pure (dedupSort $ sig::acc)
              ) authorizers sigs
            pure ()

      nonconsuming choice Go : ContractId o
        with
          inC : ContractId i
        controller op
          do
            d <- fetch inC
            archive inC
            create $ convert d

      nonconsuming choice DoUpgrade : ()
        with
          inC : ContractId i
        controller op
          do
            d <- fetch inC
            exerciseByKey @(Upgrade i o) authorizers CollectAuthority with inC = inC
            exerciseByKey @(Upgrade i o) (dedupSort $ signatory d) Go with inC = inC
            pure ()



template (Template i, Template o, UpgradeInstance i o) => UpgradeToken i o
  with
      p : Party
      op : Party
  where
      signatory p
      observer op
      key p : Party
      maintainer key

      nonconsuming choice GiveAuthority : ()
        with
          k : [Party]
        controller op
          do
            exerciseByKey @(Upgrade i o) k AddAuthority with p
            pure ()



template instance VacationUpgrade = Upgrade A.Vacation B.Vacation
template instance VacationUpgradeToken = UpgradeToken A.Vacation B.Vacation
template instance EmployeeVacationAllocationUpgrade = Upgrade A.EmployeeVacationAllocation B.EmployeeVacationAllocation
template instance EmployeeVacationAllocationUpgradeToken = UpgradeToken A.EmployeeVacationAllocation B.EmployeeVacationAllocation
template instance VacationRequestUpgrade = Upgrade A.VacationRequest B.VacationRequest
template instance VacationRequestUpgradeToken = UpgradeToken A.VacationRequest B.VacationRequest
template instance EmployeeRoleUpgrade = Upgrade A.EmployeeRole B.EmployeeRole
template instance EmployeeRoleUpgradeToken = UpgradeToken A.EmployeeRole B.EmployeeRole
template instance EmployeeProposalUpgrade = Upgrade A.EmployeeProposal B.EmployeeProposal
template instance EmployeeProposalUpgradeToken = UpgradeToken A.EmployeeProposal B.EmployeeProposal

template instance VacationRollback = Upgrade B.Vacation A.Vacation
template instance VacationRollbackToken = UpgradeToken B.Vacation A.Vacation
template instance EmployeeVacationAllocationRollback = Upgrade B.EmployeeVacationAllocation A.EmployeeVacationAllocation
template instance EmployeeVacationAllocationRollbackToken = UpgradeToken B.EmployeeVacationAllocation A.EmployeeVacationAllocation
template instance VacationRequestRollback = Upgrade B.VacationRequest A.VacationRequest
template instance VacationRequestRollbackToken = UpgradeToken B.VacationRequest A.VacationRequest
template instance EmployeeRoleRollback = Upgrade B.EmployeeRole A.EmployeeRole
template instance EmployeeRoleRollbackToken = UpgradeToken B.EmployeeRole A.EmployeeRole
template instance EmployeeProposalRollback = Upgrade B.EmployeeProposal A.EmployeeProposal
template instance EmployeeProposalRollbackToken = UpgradeToken B.EmployeeProposal A.EmployeeProposal


-----------------------
-- Contract conversions

instance Convertible A.Vacation B.Vacation where
    convert A.Vacation{..} = B.Vacation {B.employeeRole = convert employeeRole, ..}
instance Convertible B.Vacation A.Vacation where
    convert B.Vacation{..} = A.Vacation {A.employeeRole = convert employeeRole, ..}
instance Convertible A.EmployeeVacationAllocation B.EmployeeVacationAllocation where
    convert A.EmployeeVacationAllocation{..} = B.EmployeeVacationAllocation {B.employeeRole = convert employeeRole, ..}
instance Convertible B.EmployeeVacationAllocation A.EmployeeVacationAllocation where
    convert B.EmployeeVacationAllocation{..} = A.EmployeeVacationAllocation {A.employeeRole = convert employeeRole, ..}
instance Convertible A.VacationRequest B.VacationRequest where
    convert A.VacationRequest{..} = B.VacationRequest {B.vacation = convert vacation}
instance Convertible B.VacationRequest A.VacationRequest where
    convert B.VacationRequest{..} = A.VacationRequest {A.vacation = convert vacation}
instance Convertible A.EmployeeRole B.EmployeeRole where
    convert A.EmployeeRole{..} = B.EmployeeRole {..}
instance Convertible B.EmployeeRole A.EmployeeRole where
    convert B.EmployeeRole{..} = A.EmployeeRole {..}
instance Convertible A.EmployeeProposal B.EmployeeProposal where
    convert A.EmployeeProposal{..} = B.EmployeeProposal {B.employeeRole = convert employeeRole, ..}
instance Convertible B.EmployeeProposal A.EmployeeProposal where
    convert B.EmployeeProposal{..} = A.EmployeeProposal {A.employeeRole = convert employeeRole, ..}


-------------------------
-- Nano daml trigger bots

-- Upgrade whenever user signaled consent with the creation of a token
-- This doesn't work yet and runs into a daml-lf typechecker error.
-- upgradeEmployeeRoleTrigger : Trigger ()
-- upgradeEmployeeRoleTrigger = Trigger
  -- { initialize = \_acs -> ()
  -- , updateState = \_acs _message () -> ()
  -- , rule = upgradeRule
  -- , registeredTemplates =
      -- RegisteredTemplates
        -- [ registeredTemplate @(UpgradeToken A.EmployeeRole B.EmployeeRole)
        -- , registeredTemplate @(Upgrade A.EmployeeRole B.EmployeeRole)
        -- , registeredTemplate @(A.EmployeeRole)
        -- ]
  -- }

-- upgradeRule : Party -> ACS -> M.Map CommandId [Command] -> () -> TriggerA ()
-- upgradeRule party acs commandsInFlight () = do
  -- let tokens
        -- = getContracts @(UpgradeToken A.EmployeeRole B.EmployeeRole) acs
  -- let tokensWithOp op = filter (\(_tId, t) -> t.p == party && t.op == op) tokens

  -- let upgrades
        -- = getContracts @(Upgrade A.EmployeeRole B.EmployeeRole) acs

  -- let cs = getContracts @(A.EmployeeRole) acs
  -- let cs0 = filter (\(_cId, A.EmployeeRole{employee}) -> employee == party) cs

  -- unless (null tokens || null upgrades || null cs) $ do
    -- -- it would be nice if TriggerA would be an instance of ActionFail for head, guard etc.
    -- let (upgradeCoid, upgrade)::_us = upgrades
    -- when (not $ null $ tokensWithOp upgrade.op) $ do
      -- forA_ cs $ \(cId, _c)  -> dedupExercise upgradeCoid DoUpgrade with inC = cId

--------
-- Tests

-- Currently not possible to compile we

test = scenario do
  alice <- getParty "Alice"
  bob <- getParty "Bob"
  company <- getParty "DA"
  let employeeRole = A.EmployeeRole
                      with A.employee = alice
                           A.boss = bob
                           A.company = company
  propCid <- submit company $
    create $ A.EmployeeProposal with A.employeeRole = employeeRole; vacationDays = 30
  submit alice $ exercise propCid $ A.EmployeeProposal_Accept
  upCid <- submit company $
    create @(Upgrade A.EmployeeRole B.EmployeeRole) $ Upgrade {op = company, authorizers = [], obs = [alice, bob]}
  token <- submit alice $
    create @(UpgradeToken A.EmployeeRole B.EmployeeRole) $ UpgradeToken{op = company, p = alice}

  -- this is currently not possible because we miss the TemplateKey instance from the imported
  -- package
  -- submit company $ do
    -- (cid, _) <- fetchByKey @A.EmployeeRole alice
    -- exercise upCid $ DoUpgrade with inC = cid

  pure ()
