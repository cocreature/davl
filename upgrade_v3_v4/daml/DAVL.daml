daml 1.2

module DAVL where
import DAVLA qualified as A
import DAVLB qualified as B
import DA.List
import DA.Foldable (forA_)
import qualified DA.Next.Map as M
import DA.Action
import DA.Upgrade (convert, Convertible)
import qualified Daml.Trigger as T
import qualified Daml.Script as S

-----------------
-- Upgrade process
template (Template i, Template o, Convertible i o, UpgradeTokenInstance i o) => Upgrade i o
  with
      op : Party
      authorizers : [Party]
      obs : [Party]
  where
      signatory (op::authorizers)
      observer obs
      key authorizers : [Party]
      maintainer key

      nonconsuming choice GetAuthority : ()
        with
          p : Party
        controller op
          do
            exerciseByKey @(UpgradeToken i o) p GiveAuthority with k = authorizers
            pure ()

      nonconsuming choice AddAuthority : ()
        with
          p : Party
        controller p
          do
            create this with authorizers = dedupSort $ p :: authorizers
            pure ()

      nonconsuming choice CollectAuthority : ()
        with
          inC : ContractId i
        controller op
          do
            d <- fetch inC
            let sigs = signatory d
            foldlA (\acc sig -> do
              exerciseByKey @(Upgrade i o) acc GetAuthority with p = sig
              pure (dedupSort $ sig::acc)
              ) authorizers sigs
            pure ()

      nonconsuming choice Go : ContractId o
        with
          inC : ContractId i
        controller op
          do
            d <- fetch inC
            archive inC
            create $ convert d

      nonconsuming choice DoUpgrade : ()
        with
          inC : ContractId i
        controller op
          do
            d <- fetch inC
            exerciseByKey @(Upgrade i o) authorizers CollectAuthority with inC = inC
            exerciseByKey @(Upgrade i o) (dedupSort $ signatory d) Go with inC = inC
            pure ()



template (Template i, Template o, UpgradeInstance i o) => UpgradeToken i o
  with
      p : Party
      op : Party
  where
      signatory p
      observer op
      key p : Party
      maintainer key

      nonconsuming choice GiveAuthority : ()
        with
          k : [Party]
        controller op
          do
            exerciseByKey @(Upgrade i o) k AddAuthority with p
            pure ()



template instance VacationUpgrade = Upgrade A.Vacation B.Vacation
template instance VacationUpgradeToken = UpgradeToken A.Vacation B.Vacation
template instance EmployeeVacationAllocationUpgrade = Upgrade A.EmployeeVacationAllocation B.EmployeeVacationAllocation
template instance EmployeeVacationAllocationUpgradeToken = UpgradeToken A.EmployeeVacationAllocation B.EmployeeVacationAllocation
template instance VacationRequestUpgrade = Upgrade A.VacationRequest B.VacationRequest
template instance VacationRequestUpgradeToken = UpgradeToken A.VacationRequest B.VacationRequest
template instance EmployeeRoleUpgrade = Upgrade A.EmployeeRole B.EmployeeRole
template instance EmployeeRoleUpgradeToken = UpgradeToken A.EmployeeRole B.EmployeeRole
template instance EmployeeProposalUpgrade = Upgrade A.EmployeeProposal B.EmployeeProposal
template instance EmployeeProposalUpgradeToken = UpgradeToken A.EmployeeProposal B.EmployeeProposal

template instance VacationRollback = Upgrade B.Vacation A.Vacation
template instance VacationRollbackToken = UpgradeToken B.Vacation A.Vacation
template instance EmployeeVacationAllocationRollback = Upgrade B.EmployeeVacationAllocation A.EmployeeVacationAllocation
template instance EmployeeVacationAllocationRollbackToken = UpgradeToken B.EmployeeVacationAllocation A.EmployeeVacationAllocation
template instance VacationRequestRollback = Upgrade B.VacationRequest A.VacationRequest
template instance VacationRequestRollbackToken = UpgradeToken B.VacationRequest A.VacationRequest
template instance EmployeeRoleRollback = Upgrade B.EmployeeRole A.EmployeeRole
template instance EmployeeRoleRollbackToken = UpgradeToken B.EmployeeRole A.EmployeeRole
template instance EmployeeProposalRollback = Upgrade B.EmployeeProposal A.EmployeeProposal
template instance EmployeeProposalRollbackToken = UpgradeToken B.EmployeeProposal A.EmployeeProposal


-----------------------
-- Contract conversions

instance Convertible A.Vacation B.Vacation where
    convert A.Vacation{..} = B.Vacation {B.employeeRole = convert employeeRole, ..}
instance Convertible B.Vacation A.Vacation where
    convert B.Vacation{..} = A.Vacation {A.employeeRole = convert employeeRole, ..}
instance Convertible A.EmployeeVacationAllocation B.EmployeeVacationAllocation where
    convert A.EmployeeVacationAllocation{..} = B.EmployeeVacationAllocation {B.employeeRole = convert employeeRole, ..}
instance Convertible B.EmployeeVacationAllocation A.EmployeeVacationAllocation where
    convert B.EmployeeVacationAllocation{..} = A.EmployeeVacationAllocation {A.employeeRole = convert employeeRole, ..}
instance Convertible A.VacationRequest B.VacationRequest where
    convert A.VacationRequest{..} = B.VacationRequest {B.vacation = convert vacation}
instance Convertible B.VacationRequest A.VacationRequest where
    convert B.VacationRequest{..} = A.VacationRequest {A.vacation = convert vacation}
instance Convertible A.EmployeeRole B.EmployeeRole where
    convert A.EmployeeRole{..} = B.EmployeeRole {..}
instance Convertible B.EmployeeRole A.EmployeeRole where
    convert B.EmployeeRole{..} = A.EmployeeRole {..}
instance Convertible A.EmployeeProposal B.EmployeeProposal where
    convert A.EmployeeProposal{..} = B.EmployeeProposal {B.employeeRole = convert employeeRole, ..}
instance Convertible B.EmployeeProposal A.EmployeeProposal where
    convert B.EmployeeProposal{..} = A.EmployeeProposal {A.employeeRole = convert employeeRole, ..}


-------------------------
-- Nano daml trigger bots

-- Upgrade whenever user signaled consent with the creation of a token
-- This doesn't work yet and runs into a daml-lf typechecker error.
upgradeTrigger : T.Trigger ()
upgradeTrigger = T.Trigger
  { initialize = \_acs -> ()
  , updateState = \_acs _message () -> ()
  , rule = upgradeRule
  , registeredTemplates =
      T.RegisteredTemplates
        [ T.registeredTemplate @(UpgradeToken A.EmployeeRole B.EmployeeRole)
        , T.registeredTemplate @(Upgrade A.EmployeeRole B.EmployeeRole)
        , T.registeredTemplate @(A.EmployeeRole)
        ]
  }

upgradeRule : Party -> T.ACS -> M.Map T.CommandId [T.Command] -> () -> T.TriggerA ()
upgradeRule op acs commandsInFlight () = do

  -- upgrade Vacation
  let vacationTokens
        = T.getContracts @(UpgradeToken A.Vacation B.Vacation) acs
  let vacationUpgrades
        = T.getContracts @(Upgrade A.Vacation B.Vacation) acs
  let vacationCs = T.getContracts @(A.Vacation) acs
  let ready = do
              (updCid, upd) <- vacationUpgrades
              (cId, c) <- vacationCs
              let tokens = [p | (_cId, UpgradeToken{p, op}) <- vacationTokens, op == op]
              guard $ (dedupSort $ signatory c) == dedupSort tokens
              pure (updCid, cId)
  forA_ ready $ \(updCid, cId) -> T.dedupExercise updCid DoUpgrade with inC = cId

  -- upgrade EmployeeVacationAllocation
  let employeeVacationAllocationTokens
        = T.getContracts @(UpgradeToken A.EmployeeVacationAllocation B.EmployeeVacationAllocation) acs
  let employeeVacationAllocationUpgrades
        = T.getContracts @(Upgrade A.EmployeeVacationAllocation B.EmployeeVacationAllocation) acs
  let employeeVacationAllocationCs = T.getContracts @(A.EmployeeVacationAllocation) acs
  let ready = do
              (updCid, upd) <- employeeVacationAllocationUpgrades
              (cId, c) <- employeeVacationAllocationCs
              let tokens = [p | (_cId, UpgradeToken{p, op}) <- employeeVacationAllocationTokens, op == op]
              guard $ (dedupSort $ signatory c) == dedupSort tokens
              pure (updCid, cId)
  forA_ ready $ \(updCid, cId) -> T.dedupExercise updCid DoUpgrade with inC = cId

  -- upgrade VacationRequest
  let vacationRequestTokens
        = T.getContracts @(UpgradeToken A.VacationRequest B.VacationRequest) acs
  let vacationRequestUpgrades
        = T.getContracts @(Upgrade A.VacationRequest B.VacationRequest) acs
  let vacationRequestCs = T.getContracts @(A.VacationRequest) acs
  let ready = do
              (updCid, upd) <- vacationRequestUpgrades
              (cId, c) <- vacationRequestCs
              let tokens = [p | (_cId, UpgradeToken{p, op}) <- vacationRequestTokens, op == op]
              guard $ (dedupSort $ signatory c) == dedupSort tokens
              pure (updCid, cId)
  forA_ ready $ \(updCid, cId) -> T.dedupExercise updCid DoUpgrade with inC = cId

  -- upgrade EmpoyeeRole
  let employeeRoleTokens
        = T.getContracts @(UpgradeToken A.EmployeeRole B.EmployeeRole) acs
  let employeeRoleUpgrades
        = T.getContracts @(Upgrade A.EmployeeRole B.EmployeeRole) acs
  let employeeRoleCs = T.getContracts @(A.EmployeeRole) acs
  let ready = do
              (updCid, upd) <- employeeRoleUpgrades
              (cId, c) <- employeeRoleCs
              let tokens = [p | (_cId, UpgradeToken{p, op}) <- employeeRoleTokens, op == op]
              guard $ (dedupSort $ signatory c) == dedupSort tokens
              pure (updCid, cId)
  forA_ ready $ \(updCid, cId) -> T.dedupExercise updCid DoUpgrade with inC = cId

  -- upgrade EmployeeProposal
  let employeeProposalTokens
        = T.getContracts @(UpgradeToken A.EmployeeProposal B.EmployeeProposal) acs
  let employeeProposalUpgrades
        = T.getContracts @(Upgrade A.EmployeeProposal B.EmployeeProposal) acs
  let employeeProposalCs = T.getContracts @(A.EmployeeProposal) acs
  let ready = do
              (updCid, upd) <- employeeProposalUpgrades
              (cId, c) <- employeeProposalCs
              let tokens = [p | (_cId, UpgradeToken{p, op}) <- employeeProposalTokens, op == op]
              guard $ (dedupSort $ signatory c) == dedupSort tokens
              pure (updCid, cId)
  forA_ ready $ \(updCid, cId) -> T.dedupExercise updCid DoUpgrade with inC = cId


--------
-- Tests
test : S.Script ()
test = do
  alice <- S.allocateParty "Alice"
  bob <- S.allocateParty "Bob"
  company <- S.allocateParty "DA"
  debug "allocated parties"
  let employeeRole = A.EmployeeRole
                      with A.employee = alice
                           A.boss = bob
                           A.company = company
  propCid <- S.submit company $
    S.createCmd $ A.EmployeeProposal with A.employeeRole = employeeRole; vacationDays = 30
  debug "employee proposal"
  S.submit alice $ S.exerciseCmd propCid $ A.EmployeeProposal_Accept
  debug "proposal accept"
  -- This step fails because toAnyChoice is not implemented in the lf conversion of `external`.
  upCid <- S.submit company $
    S.createCmd @(Upgrade A.EmployeeRole B.EmployeeRole) $ Upgrade {op = company, authorizers = [], obs = [alice, bob]}
  debug "upgrade creation"
  token <- S.submit alice $
    S.createCmd @(UpgradeToken A.EmployeeRole B.EmployeeRole) $ UpgradeToken{op = company, p = alice}
  debug "token creation"

  cs <- S.query @A.EmployeeRole alice
  debug $ "employee role query" <> (show $ length cs)
  case cs of
    [(cid, _c)] ->
      S.submit company $ do
        S.exerciseCmd upCid $ DoUpgrade with inC = cid
    _ -> error "daml query"

test0 : Scenario ()
test0 = do
  alice <- getParty "Alice"
  bob <- getParty "Bob"
  company <- getParty "DA"
  let employeeRole = A.EmployeeRole
                      with A.employee = alice
                           A.boss = bob
                           A.company = company
  propCid <- submit company $
    create $ A.EmployeeProposal with A.employeeRole = employeeRole; vacationDays = 30
  submit alice $ exercise propCid $ A.EmployeeProposal_Accept
  upCid <- submit company $
    create @(Upgrade A.EmployeeRole B.EmployeeRole) $ Upgrade {op = company, authorizers = [], obs = [alice, bob]}
  token <- submit alice $
    create @(UpgradeToken A.EmployeeRole B.EmployeeRole) $ UpgradeToken{op = company, p = alice}
  pure ()
